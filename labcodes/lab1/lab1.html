<!DOCTYPE html>
<html>
<head>
<title>lab1.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
	font-size: 14px;
	padding: 0 12px;
	line-height: 22px;
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}


body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	color: #4080D0;
	text-decoration: none;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

h1 code,
h2 code,
h3 code,
h4 code,
h5 code,
h6 code {
	font-size: inherit;
	line-height: auto;
}

a:hover {
	color: #4080D0;
	text-decoration: underline;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left: 5px solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 14px;
	line-height: 19px;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

.mac code {
	font-size: 12px;
	line-height: 18px;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

/** Theming */

.vscode-light,
.vscode-light pre code {
	color: rgb(30, 30, 30);
}

.vscode-dark,
.vscode-dark pre code {
	color: #DDD;
}

.vscode-high-contrast,
.vscode-high-contrast pre code {
	color: white;
}

.vscode-light code {
	color: #A31515;
}

.vscode-dark code {
	color: #D7BA7D;
}

.vscode-light pre:not(.hljs),
.vscode-light code > div {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre:not(.hljs),
.vscode-dark code > div {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre:not(.hljs),
.vscode-high-contrast code > div {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

.vscode-light blockquote,
.vscode-dark blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.vscode-high-contrast blockquote {
	background: transparent;
	border-color: #fff;
}
</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family:  "Meiryo", "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

</head>
<body>
<p>OS实验报告</p>
<h1 id="lab1-%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B">Lab1 : 系统软件启动过程</h1>
<p>PB15020603 蔡心宇</p>
<hr>
<h2 id="content">Content</h2>
<ul>
<li>
<p>实验环境搭建</p>
</li>
<li>
<p>实验目的</p>
</li>
<li>
<p>实验内容与结果</p>
<ol>
<li>练习1<br>
理解通过make生成执行文件的过程</li>
<li>练习2<br>
使用 qemu 执行并调试 lab1 中的软件</li>
<li>练习3<br>
分析 bootloader 进入保护模式的过程</li>
<li>练习4<br>
分析 bootloader 加载 ELF 格式的 OS 的过程</li>
<li>练习5<br>
实现函数调用堆栈跟踪函数</li>
<li>练习6<br>
完善中断初始化和处理</li>
<li>扩展练习</li>
</ol>
</li>
</ul>
<hr>
<h2 id="%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA">环境搭建</h2>
<p>因为之前一直在Reinforcement Leaning方面的内容，所以我的电脑很早之前就装了 <code>ubuntu 16.04</code> ，而且网上安装 <code>linux</code> &amp; <code>windows</code> 双系统的教程多如牛毛而且质量大都还不错，在此不再赘述 <code>ubuntu</code> 的安装，关于环境用到的软件 <code>gcc</code>、<code>qemu</code> 等的安装实验指导书也有比较详细的介绍，也不再多说。</p>
<p>在这里主要想推荐一下一款开发工具 <code>Visual Studio Code</code> 简称 <code>VScode</code> 。</p>
<p>只是一款有Microsoft开发的免费跨平台轻量级文本编辑器，支持各种语言，插件丰富。有了这个就有了<code>代码编辑器</code>，<code>Meld</code>，<code>understand</code>，<code>Markdown</code>，<code>git</code>，<code>terminal</code> 等一系列必要的软件。</p>
<h2 id="%E5%AE%9E%E9%AA%8C%E7%9B%AE%E7%9A%84">实验目的</h2>
<p>操作系统是一个软件,也需要通过某种机制加载并运行它。在这里我们将通过另外一个更加简单的软件-bootloader 来完成这些工作。为此,我们需要完成一个能够切换到 x86的保护模式并显示字符的 bootloader,为启动操作系统 ucore 做准备。lab1 提供了一个非常小的 bootloader 和 ucore OS,整个 bootloader 执行代码小于 512 个字节,这样才能放到硬盘的主引导扇区中。通过分析和实现这个 bootloader 和 ucore OS,可以了
解到:</p>
<ul>
<li>计算机原理
<ul>
<li>CPU 的编址与寻址:基于分段机制的内存管理</li>
<li>CPU 的中断机制</li>
<li>外设:串口/并口/CGA,时钟,硬盘</li>
</ul>
</li>
<li>Bootloader 软件
<ul>
<li>编译运行 bootloader 的过程</li>
<li>调试 bootloader 的方法</li>
<li>PC 启动 bootloader 的过程</li>
<li>ELF 执行文件的格式和加载</li>
<li>外设访问:读硬盘,在 CGA 上显示字符串</li>
</ul>
</li>
<li>ucore OS 软件
<ul>
<li>编译运行 ucore OS 的过程</li>
<li>ucore OS 的启动过程</li>
<li>调试 ucore OS 的方法</li>
<li>函数调用关系:在汇编级了解函数调用栈的结构和处理过程</li>
<li>中断管理:与软件相关的中断处理</li>
<li>外设管理:时钟</li>
</ul>
</li>
</ul>
<hr>
<h2 id="%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9%E4%B8%8E%E7%BB%93%E6%9E%9C">实验内容与结果</h2>
<h3 id="%E7%BB%83%E4%B9%A01">练习1</h3>
<h4 id="11-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6-ucoreimg-%E6%98%AF%E5%A6%82%E4%BD%95%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E7%94%9F%E6%88%90%E7%9A%84">1.1 操作系统镜像文件 <code>ucore.img</code> 是如何一步一步生成的</h4>
<p>执行 <code>make V=</code></p>
<pre class="hljs"><code><div>vegelofe@vegelofe-Surface-Book:~/OS/ucore_os_lab/labcodes/lab1$ make V=
+ cc kern/init/init.c
gcc -Ikern/init/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/init/init.c -o obj/kern/init/init.o
kern/init/init.c:95:1: warning: ‘lab1_switch_test’ defined but not used [-Wunused-function]
 lab1_switch_test(void) {
 ^
+ cc kern/libs/stdio.c
gcc -Ikern/libs/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/libs/stdio.c -o obj/kern/libs/stdio.o
+ cc kern/libs/readline.c
gcc -Ikern/libs/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/libs/readline.c -o obj/kern/libs/readline.o
+ cc kern/debug/panic.c
gcc -Ikern/debug/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/debug/panic.c -o obj/kern/debug/panic.o
kern/debug/panic.c: In function ‘__panic’:
kern/debug/panic.c:27:5: warning: implicit declaration of function ‘print_stackframe’ [-Wimplicit-function-declaration]
     print_stackframe();
     ^
+ cc kern/debug/kdebug.c
gcc -Ikern/debug/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/debug/kdebug.c -o obj/kern/debug/kdebug.o
kern/debug/kdebug.c:251:1: warning: ‘read_eip’ defined but not used [-Wunused-function]
 read_eip(void) {
 ^
+ cc kern/debug/kmonitor.c
gcc -Ikern/debug/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/debug/kmonitor.c -o obj/kern/debug/kmonitor.o
+ cc kern/driver/clock.c
gcc -Ikern/driver/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/driver/clock.c -o obj/kern/driver/clock.o
+ cc kern/driver/console.c
gcc -Ikern/driver/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/driver/console.c -o obj/kern/driver/console.o
+ cc kern/driver/picirq.c
gcc -Ikern/driver/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/driver/picirq.c -o obj/kern/driver/picirq.o
+ cc kern/driver/intr.c
gcc -Ikern/driver/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/driver/intr.c -o obj/kern/driver/intr.o
+ cc kern/trap/trap.c
gcc -Ikern/trap/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/trap/trap.c -o obj/kern/trap/trap.o
kern/trap/trap.c:14:13: warning: ‘print_ticks’ defined but not used [-Wunused-function]
 static void print_ticks() {
             ^
kern/trap/trap.c:30:26: warning: ‘idt_pd’ defined but not used [-Wunused-variable]
 static struct pseudodesc idt_pd = {
                          ^
+ cc kern/trap/vectors.S
gcc -Ikern/trap/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/trap/vectors.S -o obj/kern/trap/vectors.o
+ cc kern/trap/trapentry.S
gcc -Ikern/trap/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/trap/trapentry.S -o obj/kern/trap/trapentry.o
+ cc kern/mm/pmm.c
gcc -Ikern/mm/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Ikern/debug/ -Ikern/driver/ -Ikern/trap/ -Ikern/mm/ -c kern/mm/pmm.c -o obj/kern/mm/pmm.o
+ cc libs/string.c
gcc -Ilibs/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/  -c libs/string.c -o obj/libs/string.o
+ cc libs/printfmt.c
gcc -Ilibs/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/  -c libs/printfmt.c -o obj/libs/printfmt.o
+ ld bin/kernel
ld -m    elf_i386 -nostdlib -T tools/kernel.ld -o bin/kernel  obj/kern/init/init.o obj/kern/libs/stdio.o obj/kern/libs/readline.o obj/kern/debug/panic.o obj/kern/debug/kdebug.o obj/kern/debug/kmonitor.o obj/kern/driver/clock.o obj/kern/driver/console.o obj/kern/driver/picirq.o obj/kern/driver/intr.o obj/kern/trap/trap.o obj/kern/trap/vectors.o obj/kern/trap/trapentry.o obj/kern/mm/pmm.o  obj/libs/string.o obj/libs/printfmt.o
+ cc boot/bootasm.S
gcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootasm.S -o obj/boot/bootasm.o
+ cc boot/bootmain.c
gcc -Iboot/ -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs/ -Os -nostdinc -c boot/bootmain.c -o obj/boot/bootmain.o
+ cc tools/sign.c
gcc -Itools/ -g -Wall -O2 -c tools/sign.c -o obj/sign/tools/sign.o
gcc -g -Wall -O2 obj/sign/tools/sign.o -o bin/sign
+ ld bin/bootblock
ld -m    elf_i386 -nostdlib -N -e start -Ttext 0x7C00 obj/boot/bootasm.o obj/boot/bootmain.o -o obj/bootblock.o
'obj/bootblock.out' size: 488 bytes
build 512 bytes boot sector: 'bin/bootblock' success!
dd if=/dev/zero of=bin/ucore.img count=10000
记录了10000+0 的读入
记录了10000+0 的写出
5120000 bytes (5.1 MB, 4.9 MiB) copied, 0.0297356 s, 172 MB/s
dd if=bin/bootblock of=bin/ucore.img conv=notrunc
记录了1+0 的读入
记录了1+0 的写出
512 bytes copied, 0.000203984 s, 2.5 MB/s
dd if=bin/kernel of=bin/ucore.img seek=1 conv=notrunc
记录了146+1 的读入
记录了146+1 的写出
74828 bytes (75 kB, 73 KiB) copied, 0.000724565 s, 103 MB/s
</div></code></pre>
<p>从Terminal中输出的结果中看，执行了<code>gcc</code>、<code>ld</code> 和 <code>dd</code> 3种指令。</p>
<p><code>gcc</code> 将各种 <code>.c</code>  文件和 <code>.S</code> 文件编译成为 <code>.o</code> 文件</p>
<p><code>ld</code> 将 <code>.o</code> 文件链接成可执行程序</p>
<p><code>dd</code> 利用 <code>kernel</code> 和 <code>bootblock</code> 生成最终的 <code>ucore.img</code> 。</p>
<p>但是值得注意的一点是，在 <code>/bin</code> 中还有一个 <code>sign</code> , 并没有发现有 <code>ld</code> 指令生成它， 仔细检查后发现 <code>sign</code> 是由 <code>gcc</code> 指令生成的</p>
<pre><code>gcc -g -Wall -O2 obj/sign/tools/sign.o -o bin/sign
</code></pre>
<p>但是搜索 <code>sign</code> 并没有找到哪里用到了它，由于它出现在了链接 <code>bootblock</code> 的 <code>ld</code> 指令之前，于是打开 <code>Makefile</code> 查找 <code>sign</code> 果真在如下生成 <code>bootblock</code> 的指令中找到了 <code>sign</code> 。</p>
<pre class="hljs"><code><div>	@<span class="hljs-variable">$(OBJCOPY)</span> -S -O binary <span class="hljs-variable">$(<span class="hljs-built_in">call</span> objfile,bootblock)</span> <span class="hljs-variable">$(<span class="hljs-built_in">call</span> outfile,bootblock)</span>
	@<span class="hljs-variable">$(<span class="hljs-built_in">call</span> totarget,sign)</span> <span class="hljs-variable">$(<span class="hljs-built_in">call</span> outfile,bootblock)</span> <span class="hljs-variable">$(bootblock)</span>
</div></code></pre>
<p>可见先把 <code>bootblock.o</code> copy成了 <code>bootblock.out</code> 然后调用了sign来处理 <code>bootblock.out</code></p>
<p>在Terminal的输出中，可以找到这两句</p>
<pre class="hljs"><code><div>'obj/bootblock.out' size: 488 bytes
build 512 bytes boot sector: 'bin/bootblock' success!
</div></code></pre>
<p>查看 <code>sign.c</code> 可以找到对应的这输出两句的代码，而且很容易可以发现 <code>sign</code> 的功能是将 <code>bootblock.out</code> 读入后扩充为512字节（补0），并且将最后两字节置为 <code>0x55aa</code> 写入 <code>bootblock</code> 中。</p>
<pre class="hljs"><code><div>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"'%s' size: %lld bytes\n"</span>, argv[<span class="hljs-number">1</span>], (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)st.st_size);

    ......<span class="hljs-comment">//中间省略</span>
    
    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">512</span>];
    <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(buf));
    FILE *ifp = fopen(argv[<span class="hljs-number">1</span>], <span class="hljs-string">"rb"</span>);
    <span class="hljs-keyword">int</span> size = fread(buf, <span class="hljs-number">1</span>, st.st_size, ifp);
    <span class="hljs-keyword">if</span> (size != st.st_size) {
        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"read '%s' error, size is %d.\n"</span>, argv[<span class="hljs-number">1</span>], size);
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    }
    fclose(ifp);
    buf[<span class="hljs-number">510</span>] = <span class="hljs-number">0x55</span>;
    buf[<span class="hljs-number">511</span>] = <span class="hljs-number">0xAA</span>;
    FILE *ofp = fopen(argv[<span class="hljs-number">2</span>], <span class="hljs-string">"wb+"</span>);
    size = fwrite(buf, <span class="hljs-number">1</span>, <span class="hljs-number">512</span>, ofp);
    <span class="hljs-keyword">if</span> (size != <span class="hljs-number">512</span>) {
        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"write '%s' error, size is %d.\n"</span>, argv[<span class="hljs-number">2</span>], size);
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    }
    fclose(ofp);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"build 512 bytes boot sector: '%s' success!\n"</span>, argv[<span class="hljs-number">2</span>]);
</div></code></pre>
<p>用 <code>xxd</code> 查看 <code>bootblock</code> 可见确实如此</p>
<pre class="hljs"><code><div>vegelofe@vegelofe-Surface-Book:~/OS/ucore_os_lab/labcodes/lab1$ xxd bin/bootblock
00000000: fafc 31c0 8ed8 8ec0 8ed0 e464 a802 75fa  ..1........d..u.
00000010: b0d1 e664 e464 a802 75fa b0df e660 0f01  ...d.d..u....`..
00000020: 166c 7c0f 20c0 6683 c801 0f22 c0ea 327c  .l|. .f....&quot;..2|
00000030: 0800 66b8 1000 8ed8 8ec0 8ee0 8ee8 8ed0  ..f.............
00000040: bd00 0000 00bc 007c 0000 e8be 0000 00eb  .......|........
00000050: fe8d 7600 0000 0000 0000 0000 ffff 0000  ..v.............
00000060: 009a cf00 ffff 0000 0092 cf00 1700 547c  ..............T|
00000070: 0000 5589 e557 8d3c 1089 cac1 e909 5681  ..U..W.&lt;......V.
00000080: e2ff 0100 008d 7101 5329 d053 897d f089  ......q.S).S.}..
00000090: c33b 5df0 7371 baf7 0100 00ec 83e0 c03c  .;].sq.........&lt;
000000a0: 4075 f3ba f201 0000 b001 eeba f301 0000  @u..............
000000b0: 89f0 ee89 f0ba f401 0000 c1e8 08ee 89f0  ................
000000c0: baf5 0100 00c1 e810 ee89 f0ba f601 0000  ................
000000d0: c1e8 1883 e00f 83c8 e0ee b020 baf7 0100  ........... ....
000000e0: 00ee baf7 0100 00ec 83e0 c03c 4075 f389  ...........&lt;@u..
000000f0: dfb9 8000 0000 baf0 0100 00fc f26d 81c3  .............m..
00000100: 0002 0000 46eb 8a58 5b5e 5f5d c355 31c9  ....F..X[^_].U1.
00000110: ba00 1000 00b8 0000 0100 89e5 5653 e84f  ............VS.O
00000120: ffff ff81 3d00 0001 007f 454c 4675 3fa1  ....=.....ELFu?.
00000130: 1c00 0100 0fb7 352c 0001 008d 9800 0001  ......5,........
00000140: 00c1 e605 01de 39f3 7318 8b43 088b 4b04  ......9.s..C..K.
00000150: 83c3 208b 53f4 25ff ffff 00e8 12ff ffff  .. .S.%.........
00000160: ebe4 a118 0001 0025 ffff ff00 ffd0 ba00  .......%........
00000170: 8aff ff89 d066 efb8 008e ffff 66ef ebfe  .....f......f...
00000180: 1400 0000 0000 0000 017a 5200 017c 0801  .........zR..|..
00000190: 1b0c 0404 8801 0000 2c00 0000 1c00 0000  ........,.......
000001a0: d2fe ffff 9b00 0000 0041 0e08 8502 420d  .........A....B.
000001b0: 0541 8703 4f86 0446 8305 027e c341 c641  .A..O..F...~.A.A
000001c0: c741 c50c 0404 0000 1c00 0000 4c00 0000  .A..........L...
000001d0: 3dff ffff 7300 0000 0041 0e08 8502 4e0d  =...s....A....N.
000001e0: 0542 8603 8304 0000 0000 0000 0000 0000  .B..............
000001f0: 0000 0000 0000 0000 0000 0000 0000 55aa  ..............U.
</div></code></pre>
<h4 id="12-%E4%B8%80%E4%B8%AA%E8%A2%AB%E7%B3%BB%E7%BB%9F%E8%AE%A4%E4%B8%BA%E6%98%AF%E7%AC%A6%E5%90%88%E8%A7%84%E8%8C%83%E7%9A%84%E7%A1%AC%E7%9B%98%E4%B8%BB%E5%BC%95%E5%AF%BC%E6%89%87%E5%8C%BA%E7%9A%84%E7%89%B9%E5%BE%81%E6%98%AF%E4%BB%80%E4%B9%88">1.2 一个被系统认为是符合规范的硬盘主引导扇区的特征是什么</h4>
<p>根据上面的讨论，不难看出：符合规范的硬盘主引导扇区要有512字节而且最后两个字节为 <code>0x55aa</code></p>
<h3 id="%E7%BB%83%E4%B9%A02">练习2</h3>
<h4 id="21-%E4%BB%8Ecpu%E5%8A%A0%E7%94%B5%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9D%A1%E6%8C%87%E4%BB%A4%E5%BC%80%E5%A7%8B%E5%8D%95%E6%AD%A5%E8%B7%9F%E8%B8%AAbios%E7%9A%84%E6%89%A7%E8%A1%8C">2.1 从CPU加电后执行的第一条指令开始,单步跟踪BIOS的执行</h4>
<p>在 <code>gdbinit</code> 中改为</p>
<pre class="hljs"><code><div>set architecture i8086
target remote :1234
x /2i $pc
</div></code></pre>
<p>然后修改 <code>Makefile</code> 中的 <code>debug</code> 中的内容第一句</p>
<pre class="hljs"><code><div><span class="hljs-section">debug: <span class="hljs-variable">$(UCOREIMG)</span></span>
	<span class="hljs-comment"># $(V)$(QEMU) -S -s -parallel stdio -hda $&lt; -serial null &amp;</span>
    <span class="hljs-variable">$(V)</span><span class="hljs-variable">$(TERMINAL)</span> -e <span class="hljs-string">"<span class="hljs-variable">$(QEMU)</span> -S -s -d in_asm -D <span class="hljs-variable">$(BINDIR)</span>/q.log -parallel stdio -hda <span class="hljs-variable">$&lt;</span> -serial null"</span>
	<span class="hljs-variable">$(V)</span>sleep 2
	<span class="hljs-variable">$(V)</span><span class="hljs-variable">$(TERMINAL)</span> -e <span class="hljs-string">"gdb -q -tui -x tools/gdbinit"</span>
</div></code></pre>
<p>执行 <code>make debug</code></p>
<pre class="hljs"><code><div>The target architecture is assumed to be i8086
0x0000fff0 in ?? ()
=&gt; 0xfff0:      add    %al,(%bx,%si)
   0xfff2:      add    %al,(%bx,%si)
(gdb) si
0x0000e05b in ?? ()
(gdb) x /10i $pc
=&gt; 0xe05b:      add    %al,(%bx,%si)
   0xe05d:      add    %al,(%bx,%si)
   0xe05f:      add    %al,(%bx,%si)
   0xe061:      add    %al,(%bx,%si)
   0xe063:      add    %al,(%bx,%si)
   0xe065:      add    %al,(%bx,%si)
   0xe067:      add    %al,(%bx,%si)
   0xe069:      add    %al,(%bx,%si)
   0xe06b:      add    %al,(%bx,%si)
   0xe06d:      add    %al,(%bx,%si)
(gdb) si
0x0000e062 in ?? ()
0x0000e066 in ?? ()
0x0000e068 in ?? ()
0x0000e06a in ?? ()
0x0000e070 in ?? ()
0x0000e076 in ?? ()
0x0000d165 in ?? ()
(gdb) x /10i $pc
=&gt; 0xd165:      add    %al,(%bx,%si)
   0xd167:      add    %al,(%bx,%si)
   0xd169:      add    %al,(%bx,%si)
   0xd16b:      add    %al,(%bx,%si)
   0xd16d:      add    %al,(%bx,%si)
   0xd16f:      add    %al,(%bx,%si)
   0xd171:      add    %al,(%bx,%si)
   0xd173:      add    %al,(%bx,%si)
   0xd175:      add    %al,(%bx,%si)
   0xd177:      add    %al,(%bx,%si)

</div></code></pre>
<p>发现 <code>gdb</code> 中出现的并不是所期待的长跳指令，而后面给着的一系列指令都是没有任何意义的，但是查看 <code>q.log</code> 日志就会发现实际执行的指令并不是这些，第一条指令确实是位于 <code>0xfffffff0</code> 的长跳指令。</p>
<h4 id="22-%E5%9C%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BD%8D%E7%BD%AE-0x7c00-%E8%AE%BE%E7%BD%AE%E5%AE%9E%E5%9C%B0%E5%9D%80%E6%96%AD%E7%82%B9%E6%B5%8B%E8%AF%95%E6%96%AD%E7%82%B9%E6%AD%A3%E5%B8%B8">2.2 在初始化位置 <code>0x7c00</code> 设置实地址断点,测试断点正常</h4>
<p>将 <code>gdbinit</code> 修改为如下内容</p>
<pre class="hljs"><code><div>set architecture i8086
target remote :1234
b *0x7c00
c
x /2i $pc
set architecture i386
</div></code></pre>
<p>执行 <code>make debug</code> 可以得到如下结果</p>
<pre class="hljs"><code><div>The target architecture is assumed to be i8086
0x0000fff0 in ?? ()
Breakpoint 1 at 0x7c00

Breakpoint 1, 0x00007c00 in ?? ()
=&gt; 0x7c00:      cli
   0x7c01:      cld
---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---
</div></code></pre>
<h4 id="23-%E4%BB%8E-0x7c00-%E5%BC%80%E5%A7%8B%E8%B7%9F%E8%B8%AA%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E5%B0%86%E5%8D%95%E6%AD%A5%E8%B7%9F%E8%B8%AA%E5%8F%8D%E6%B1%87%E7%BC%96%E5%BE%97%E5%88%B0%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%8E-bootasms-%E5%92%8C-bootblockasm-%E8%BF%9B%E8%A1%8C%E6%AF%94%E8%BE%83">2.3 从 <code>0x7c00</code> 开始跟踪代码运行,将单步跟踪反汇编得到的代码与 <code>bootasm.S</code> 和 <code>bootblock.asm</code> 进行比较</h4>
<p>继续作如下操作</p>
<pre class="hljs"><code><div>The target architecture is assumed to be i386
(gdb) x /10i $pc
=&gt; 0x7c00:      cli
   0x7c01:      cld
   0x7c02:      xor    %eax,%eax
   0x7c04:      mov    %eax,%ds
   0x7c06:      mov    %eax,%es
   0x7c08:      mov    %eax,%ss
   0x7c0a:      in     $0x64,%al
   0x7c0c:      test   $0x2,%al
   0x7c0e:      jne    0x7c0a
   0x7c10:      mov    $0xd1,%al
</div></code></pre>
<p>与 <code>bootasm.S</code> 和 <code>bootblock.asm</code> 比较，发现他们是相同的</p>
<pre class="hljs"><code><div>.code16                                             # Assemble for 16-bit mode
    cli                                             # Disable interrupts
    cld                                             # String operations increment

    # Set up the important data segment registers (DS, ES, SS).
    xorw %ax, %ax                                   # Segment number zero
    movw %ax, %ds                                   # -&gt; Data Segment
    movw %ax, %es                                   # -&gt; Extra Segment
    movw %ax, %ss                                   # -&gt; Stack Segment

    # Enable A20:
    #  For backwards compatibility with the earliest PCs, physical
    #  address line 20 is tied low, so that addresses higher than
    #  1MB wrap around to zero by default. This code undoes this.
seta20.1:
    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).
    testb $0x2, %al
    jnz seta20.1

    movb $0xd1, %al                                 # 0xd1 -&gt; port 0x64
    outb %al, $0x64                                 # 0xd1 means: write data to 8042's P2 port
</div></code></pre>
<pre class="hljs"><code><div>.code16                                             # Assemble for 16-bit mode
    cli                                             # Disable interrupts
    7c00:	fa                   	cli    
    cld                                             # String operations increment
    7c01:	fc                   	cld    

    # Set up the important data segment registers (DS, ES, SS).
    xorw %ax, %ax                                   # Segment number zero
    7c02:	31 c0                	xor    %eax,%eax
    movw %ax, %ds                                   # -&gt; Data Segment
    7c04:	8e d8                	mov    %eax,%ds
    movw %ax, %es                                   # -&gt; Extra Segment
    7c06:	8e c0                	mov    %eax,%es
    movw %ax, %ss                                   # -&gt; Stack Segment
    7c08:	8e d0                	mov    %eax,%ss

00007c0a &lt;seta20.1&gt;:
    # Enable A20:
    #  For backwards compatibility with the earliest PCs, physical
    #  address line 20 is tied low, so that addresses higher than
    #  1MB wrap around to zero by default. This code undoes this.
seta20.1:
    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).
    7c0a:	e4 64                	in     $0x64,%al
    testb $0x2, %al
    7c0c:	a8 02                	test   $0x2,%al
    jnz seta20.1
    7c0e:	75 fa                	jne    7c0a &lt;seta20.1&gt;

    movb $0xd1, %al                                 # 0xd1 -&gt; port 0x64
    7c10:	b0 d1                	mov    $0xd1,%al
    outb %al, $0x64                                 # 0xd1 means: write data to 8042's P2 port
    7c12:	e6 64                	out    %al,$0x64

00007c14 &lt;seta20.2&gt;:

seta20.2:
    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).
    7c14:	e4 64                	in     $0x64,%al
    testb $0x2, %al
    7c16:	a8 02                	test   $0x2,%al
    jnz seta20.2
    7c18:	75 fa                	jne    7c14 &lt;seta20.2&gt;

    movb $0xdf, %al                                 # 0xdf -&gt; port 0x60
    7c1a:	b0 df                	mov    $0xdf,%al
    outb %al, $0x60                                 # 0xdf = 11011111, means set P2's A20 bit(the 1 bit) to 1
    7c1c:	e6 60                	out    %al,$0x60
</div></code></pre>
<h4 id="24-%E8%87%AA%E5%B7%B1%E6%89%BE%E4%B8%80%E4%B8%AAbootloader%E6%88%96%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BD%8D%E7%BD%AE%E8%AE%BE%E7%BD%AE%E6%96%AD%E7%82%B9%E5%B9%B6%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95">2.4 自己找一个bootloader或内核中的代码位置,设置断点并进行测试</h4>
<p>将 <code>gdbinit</code> 中 <code>b *0x7c00</code> 改为 <code>b *0x100000</code> ，执行 <code>make debug</code> 得到如下结果</p>
<pre class="hljs"><code><div>The target architecture is assumed to be i8086
0x0000fff0 in ?? ()
Breakpoint 1 at 0x100000

Breakpoint 1, 0x00100000 in ?? ()
=&gt; 0x100000:    push   %bp
   0x100001:    mov    %sp,%bp
---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---
The target architecture is assumed to be i386
(gdb) x /10i $pc
=&gt; 0x100000:    push   %ebp
   0x100001:    mov    %esp,%ebp
   0x100003:    sub    $0x18,%esp
   0x100006:    mov    $0x10fd20,%edx
   0x10000b:    mov    $0x10ea16,%eax
   0x100010:    sub    %eax,%edx
   0x100012:    mov    %edx,%eax
   0x100014:    sub    $0x4,%esp
   0x100017:    push   %eax
   0x100018:    push   $0x0 
</div></code></pre>
<p>与 <code>kernel.asm</code> 比较，发现他们是一致的</p>
<pre class="hljs"><code><div>int
kern_init(void) {
  100000:	55                   	push   %ebp
  100001:	89 e5                	mov    %esp,%ebp
  100003:	83 ec 18             	sub    $0x18,%esp
    extern char edata[], end[];
    memset(edata, 0, end - edata);
  100006:	ba 20 fd 10 00       	mov    $0x10fd20,%edx
  10000b:	b8 16 ea 10 00       	mov    $0x10ea16,%eax
  100010:	29 c2                	sub    %eax,%edx
  100012:	89 d0                	mov    %edx,%eax
  100014:	83 ec 04             	sub    $0x4,%esp
  100017:	50                   	push   %eax
  100018:	6a 00                	push   $0x0
</div></code></pre>
<h3 id="%E7%BB%83%E4%B9%A03">练习3</h3>
<h4 id="31-%E4%BD%BF%E8%83%BD-a20-%E5%9C%B0%E5%9D%80%E7%BA%BF">3.1 使能 <code>A20</code> 地址线</h4>
<p>根据附录中的，当 <code>80286</code> 出现时，为了完全向下兼容 <code>8086</code> 的<code>实模式</code>，需要屏蔽 <code>A20</code> 地址线，然而为了进入<code>保护模式</code>，必须使能 <code>A20</code> 地址线才能寻址超过1MB的空间。使能 <code>A20</code> 的操作如下</p>
<ol>
<li>等待8042	Input	buffer为空;</li>
<li>发送Write	8042	Output	Port	(P2)命令到8042	Input	buffer;</li>
<li>等待8042	Input	buffer为空;</li>
<li>将8042	Output	Port(P2)得到字节的第2位置1,然后写入8042	Input	buffer;</li>
</ol>
<p>对比 <code>bootasm.S</code> 中的代码，可以看出他们是一致的</p>
<pre class="hljs"><code><div>    # Enable A20:
seta20.1:
    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).
    testb $0x2, %al
    jnz seta20.1

    movb $0xd1, %al                                 # 0xd1 -&gt; port 0x64
    outb %al, $0x64                                 # 0xd1 means: write data to 8042's P2 port

seta20.2:
    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).
    testb $0x2, %al
    jnz seta20.2

    movb $0xdf, %al                                 # 0xdf -&gt; port 0x60
    outb %al, $0x60                                 # 0xdf = 11011111, means set P2's A20 bit(the 1 bit) to 1
</div></code></pre>
<h4 id="32-%E5%88%9D%E5%A7%8B%E5%8C%96-gdt-%E8%A1%A8">3.2 初始化 <code>GDT</code> 表</h4>
<p>因为 <code>保护模式</code> 使用 <code>分段储存管理机制</code> ，所以需要初始换 <code>GDT</code> 表，在使能 <code>A20</code> 的代码下面可以找相应的指令</p>
<pre><code>lgdt gdtdesc
</code></pre>
<p>在最下面还能找到 <code>GDT</code> 表的相关初始化信息，包括空段、代码段和数据段</p>
<pre class="hljs"><code><div># Bootstrap GDT
.p2align 2                                          # force 4 byte alignment
gdt:
    SEG_NULLASM                                     # null seg
    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           # code seg for bootloader and kernel
    SEG_ASM(STA_W, 0x0, 0xffffffff)                 # data seg for bootloader and kernel

gdtdesc:
    .word 0x17                                      # sizeof(gdt) - 1
    .long gdt 
</div></code></pre>
<h4 id="33-%E4%BD%BF%E8%83%BD%E5%92%8C%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F">3.3 使能和进入保护模式</h4>
<p>接下来的操作就是使能保护模式，需要将 <code>cr0</code> 寄存器的 <code>PE</code> 位 <code>置1</code>，相关代码如下</p>
<pre class="hljs"><code><div>    movl %cr0, %eax
    orl $CR0_PE_ON, %eax
    movl %eax, %cr0
</div></code></pre>
<p>此时虽然已经使能保护模式，但是 <code>cs</code> 中还不是 <code>segment selector</code>
执行</p>
<pre><code>    ljmp $PROT_MODE_CSEG, $protcseg
</code></pre>
<p>可以将 <code>PROT_MODE_CSEG</code> 的值 <code>0x8</code>放入 <code>cs</code> 中，然后继续执行 <code>protcseg</code> 中初始化数据段和堆栈的指令，这就真正进入了保护模式</p>
<h3 id="%E7%BB%83%E4%B9%A04">练习4</h3>
<p>在初始化堆栈之后会有</p>
<pre><code>    call bootmain
</code></pre>
<p>调用 <code>bootmain</code> 函数，它就是用来将硬盘中 <code>ELF</code> 格式的 <code>kernel</code> 加载到内存中</p>
<h4 id="41-bootloader%E5%A6%82%E4%BD%95%E8%AF%BB%E5%8F%96%E7%A1%AC%E7%9B%98%E6%89%87%E5%8C%BA%E7%9A%84">4.1 bootloader如何读取硬盘扇区的</h4>
<ol>
<li>等待磁盘准备好</li>
<li>发出读取扇区的命令</li>
<li>等待磁盘准备好</li>
<li>把磁盘扇区数据读到指定内存</li>
</ol>
<p>在 <code>bootmain.c</code> 中可以找到 <code>readsect</code> 函数用于读取 <code>secno</code> 扇区内容到内存的 <code>dst</code> 处</p>
<pre class="hljs"><code><div><span class="hljs-comment">/* readsect - read a single sector at @secno into @dst */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>
<span class="hljs-title">readsect</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *dst, <span class="hljs-keyword">uint32_t</span> secno)</span> </span>{
    <span class="hljs-comment">// wait for disk to be ready</span>
    waitdisk();

    outb(<span class="hljs-number">0x1F2</span>, <span class="hljs-number">1</span>);                         <span class="hljs-comment">// count = 1</span>
    outb(<span class="hljs-number">0x1F3</span>, secno &amp; <span class="hljs-number">0xFF</span>);
    outb(<span class="hljs-number">0x1F4</span>, (secno &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xFF</span>);
    outb(<span class="hljs-number">0x1F5</span>, (secno &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xFF</span>);
    outb(<span class="hljs-number">0x1F6</span>, ((secno &gt;&gt; <span class="hljs-number">24</span>) &amp; <span class="hljs-number">0xF</span>) | <span class="hljs-number">0xE0</span>);
    outb(<span class="hljs-number">0x1F7</span>, <span class="hljs-number">0x20</span>);                      <span class="hljs-comment">// cmd 0x20 - read sectors</span>

    <span class="hljs-comment">// wait for disk to be ready</span>
    waitdisk();

    <span class="hljs-comment">// read a sector</span>
    insl(<span class="hljs-number">0x1F0</span>, dst, SECTSIZE / <span class="hljs-number">4</span>);
}

</div></code></pre>
<p>然后又用 <code>readseg</code> 函数将其封装，可以读取 <code>offset</code> 处的 <code>count</code> 个字节到内存 <code>va</code> 处</p>
<pre class="hljs"><code><div><span class="hljs-comment">/* *
 * readseg - read @count bytes at @offset from kernel into virtual address @va,
 * might copy more than asked.
 * */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>
<span class="hljs-title">readseg</span><span class="hljs-params">(<span class="hljs-keyword">uintptr_t</span> va, <span class="hljs-keyword">uint32_t</span> count, <span class="hljs-keyword">uint32_t</span> offset)</span> </span>{
    <span class="hljs-keyword">uintptr_t</span> end_va = va + count;

    <span class="hljs-comment">// round down to sector boundary</span>
    va -= offset % SECTSIZE;

    <span class="hljs-comment">// translate from bytes to sectors; kernel starts at sector 1</span>
    <span class="hljs-keyword">uint32_t</span> secno = (offset / SECTSIZE) + <span class="hljs-number">1</span>;

    <span class="hljs-comment">// If this is too slow, we could read lots of sectors at a time.</span>
    <span class="hljs-comment">// We'd write more to memory than asked, but it doesn't matter --</span>
    <span class="hljs-comment">// we load in increasing order.</span>
    <span class="hljs-keyword">for</span> (; va &lt; end_va; va += SECTSIZE, secno ++) {
        readsect((<span class="hljs-keyword">void</span> *)va, secno);
    }
}
</div></code></pre>
<h4 id="42-bootloader%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BDelf%E6%A0%BC%E5%BC%8F%E7%9A%84os">4.2 bootloader是如何加载ELF格式的OS</h4>
<p>封装好 <code>readseg</code> 函数后在 <code>bootmain</code> 中调用它，来加载 <code>ELF</code> 格式的 <code>OS</code></p>
<pre class="hljs"><code><div><span class="hljs-comment">/* bootmain - the entry of bootloader */</span>
<span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">bootmain</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
    <span class="hljs-comment">// read the 1st page off disk</span>
    readseg((<span class="hljs-keyword">uintptr_t</span>)ELFHDR, SECTSIZE * <span class="hljs-number">8</span>, <span class="hljs-number">0</span>);

    <span class="hljs-comment">// is this a valid ELF?</span>
    <span class="hljs-keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC) {
        <span class="hljs-keyword">goto</span> bad;
    }

    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proghdr</span> *<span class="hljs-title">ph</span>, *<span class="hljs-title">eph</span>;</span>

    <span class="hljs-comment">// load each program segment (ignores ph flags)</span>
    ph = (struct proghdr *)((<span class="hljs-keyword">uintptr_t</span>)ELFHDR + ELFHDR-&gt;e_phoff);
    eph = ph + ELFHDR-&gt;e_phnum;
    <span class="hljs-keyword">for</span> (; ph &lt; eph; ph ++) {
        readseg(ph-&gt;p_va &amp; <span class="hljs-number">0xFFFFFF</span>, ph-&gt;p_memsz, ph-&gt;p_offset);
    }

    <span class="hljs-comment">// call the entry point from the ELF header</span>
    <span class="hljs-comment">// note: does not return</span>
    ((<span class="hljs-keyword">void</span> (*)(<span class="hljs-keyword">void</span>))(ELFHDR-&gt;e_entry &amp; <span class="hljs-number">0xFFFFFF</span>))();
</div></code></pre>
<p>先加载第一个扇区，然后再将数据段全部加载进入内存，最后转到 <code>kernel</code> 的起始地址开始执行。</p>
<p>但是一些细节仍然需要思考，在一开始有 <code>ELFHDR</code> 的定义</p>
<pre class="hljs"><code><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ELFHDR          ((struct elfhdr *)0x10000)      <span class="hljs-comment">// scratch space</span></span>
</div></code></pre>
<p>可以看出它是一个指向 <code>elfhdr</code> 类型的结构体的指针，值为 <code>0x10000</code></p>
<p>在 <code>bootblock.asm</code> 中查找下面这句代码的汇编指令</p>
<pre class="hljs"><code><div>    ((<span class="hljs-keyword">void</span> (*)(<span class="hljs-keyword">void</span>))(ELFHDR-&gt;e_entry &amp; <span class="hljs-number">0xFFFFFF</span>))();
</div></code></pre>
<p>可以找到</p>
<pre class="hljs"><code><div>    ((void (*)(void))(ELFHDR-&gt;e_entry &amp; 0xFFFFFF))();
    7d62:	a1 18 00 01 00       	mov    0x10018,%eax
    7d67:	25 ff ff ff 00       	and    $0xffffff,%eax
    7d6c:	ff d0                	call   *%eax
</div></code></pre>
<p>但我们并不知道 <code>0x10018</code> 和 <code>eax</code> 寄存器的值
通过查看 <code>q.log</code> 可以发现执行 <code>call</code> 指令后，跳到了 <code>0x100000</code> 处执行</p>
<pre class="hljs"><code><div>IN: 
0x00007d62:  mov    0x10018,%eax
0x00007d67:  and    $0xffffff,%eax
0x00007d6c:  call   *%eax

----------------
IN: 
0x00100000:  push   %ebp
0x00100001:  mov    %esp,%ebp
0x00100003:  sub    $0x18,%esp
0x00100006:  mov    $0x10fd20,%edx
0x0010000b:  mov    $0x10ea16,%eax
0x00100010:  sub    %eax,%edx
0x00100012:  mov    %edx,%eax
0x00100014:  sub    $0x4,%esp
0x00100017:  push   %eax
0x00100018:  push   $0x0
0x0010001a:  push   $0x10ea16
0x0010001f:  call   0x102a26

----------------
</div></code></pre>
<p>而查看 <code>kernel.asm</code> 可以发现，这正是 <code>kernel</code> 的起始地址</p>
<pre class="hljs"><code><div>int
kern_init(void) {
  100000:	55                   	push   %ebp
  100001:	89 e5                	mov    %esp,%ebp
  100003:	83 ec 18             	sub    $0x18,%esp
    extern char edata[], end[];
    memset(edata, 0, end - edata);
  100006:	ba 20 fd 10 00       	mov    $0x10fd20,%edx
  10000b:	b8 16 ea 10 00       	mov    $0x10ea16,%eax
</div></code></pre>
<p>至此，<code>bootloader</code> 的工作已经完成，接下来进入操作系统的内核。</p>
<h3 id="%E7%BB%83%E4%B9%A05">练习5</h3>
<h4 id="51-%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E8%B7%9F%E8%B8%AA%E5%87%BD%E6%95%B0">5.1 实现函数调用堆栈跟踪函数</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">print_stackframe</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
     <span class="hljs-comment">/* LAB1 YOUR CODE : STEP 1 */</span>
     <span class="hljs-comment">/* (1) call read_ebp() to get the value of ebp. the type is (uint32_t);
      * (2) call read_eip() to get the value of eip. the type is (uint32_t);
      * (3) from 0 .. STACKFRAME_DEPTH
      *    (3.1) printf value of ebp, eip
      *    (3.2) (uint32_t)calling arguments [0..4] = the contents in address (uint32_t)ebp +2 [0..4]
      *    (3.3) cprintf("\n");
      *    (3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc.
      *    (3.5) popup a calling stackframe
      *           NOTICE: the calling funciton's return addr eip  = ss:[ebp+4]
      *                   the calling funciton's ebp = ss:[ebp]
      */</span>
    <span class="hljs-keyword">uint32_t</span> ebp = read_ebp();
    <span class="hljs-keyword">uint32_t</span> eip = read_eip();
    
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; ebp != <span class="hljs-number">0</span> &amp;&amp; i &lt; STACKFRAME_DEPTH; i++)
    {
        cprintf(<span class="hljs-string">"ebp:0x%08x eip:0x%08x args:"</span>, ebp, eip);
        <span class="hljs-keyword">uint32_t</span> *args = (<span class="hljs-keyword">uint32_t</span> *)ebp + <span class="hljs-number">2</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++)
        {
            cprintf(<span class="hljs-string">"0x%08x "</span>, args[j]);
        }
        cprintf(<span class="hljs-string">"\n"</span>);
        print_debuginfo(eip <span class="hljs-number">-1</span>);
        eip = *((<span class="hljs-keyword">uint32_t</span> *)(ebp + <span class="hljs-number">4</span>));
        <span class="hljs-comment">//eip = *((uint32_t *)ebp + 1);</span>
        ebp = *((<span class="hljs-keyword">uint32_t</span> *)ebp);
    }
}
</div></code></pre>
<p>注释已经写的很清楚，需要注意的就是，<code>ebp</code> 下面就是函数调用返回时需要执行的指令的地址，即 <code>（ebp + 4）</code> 处的值就是 <code>eip</code>。 而且 <code>（ebp）</code> 处存的值就是父函数 的 <code>ebp</code> 值。</p>
<pre class="hljs"><code><div>vegelofe@vegelofe-Surface-Book:~/OS/ucore_os_lab/labcodes/lab1$ make qemu
WARNING: Image format was not specified for 'bin/ucore.img' and probing guessed raw.
         Automatically detecting the format is dangerous for raw images, write operations on block 0 will be restricted.
         Specify the 'raw' format explicitly to remove the restrictions.
main-loop: WARNING: I/O thread spun for 1000 iterations
(THU.CST) os is loading ...

Special kernel symbols:
  entry  0x00100000 (phys)
  etext  0x0010327c (phys)
  edata  0x0010ea16 (phys)
  end    0x0010fd20 (phys)
Kernel executable memory footprint: 64KB
ebp:0x00007b38 eip:0x00100a3c args:0x00010094 0x00010094 0x00007b68 0x0010007f
    kern/debug/kdebug.c:306: print_stackframe+21
ebp:0x00007b48 eip:0x00100d3c args:0x00000000 0x00000000 0x00000000 0x00007bb8
    kern/debug/kmonitor.c:125: mon_backtrace+10
ebp:0x00007b68 eip:0x0010007f args:0x00000000 0x00007b90 0xffff0000 0x00007b94
    kern/init/init.c:48: grade_backtrace2+19
ebp:0x00007b88 eip:0x001000a1 args:0x00000000 0xffff0000 0x00007bb4 0x00000029
    kern/init/init.c:53: grade_backtrace1+27
ebp:0x00007ba8 eip:0x001000be args:0x00000000 0x00100000 0xffff0000 0x00100043
    kern/init/init.c:58: grade_backtrace0+19
ebp:0x00007bc8 eip:0x001000df args:0x00000000 0x00000000 0x00000000 0x00103280
    kern/init/init.c:63: grade_backtrace+26
ebp:0x00007be8 eip:0x00100050 args:0x00000000 0x00000000 0x00000000 0x00007c4f
    kern/init/init.c:28: kern_init+79
ebp:0x00007bf8 eip:0x00007d6e args:0xc031fcfa 0xc08ed88e 0x64e4d08e 0xfa7502a8
    &lt;unknow&gt;: -- 0x00007d6d --
++ setup timer interrupts
</div></code></pre>
<p>可以看到执行 <code>make qemu</code> 的输出确实符合函数调用树。</p>
<h3 id="%E7%BB%83%E4%B9%A06">练习6</h3>
<h4 id="61-%E4%B8%AD%E6%96%AD%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%E4%B8%AD%E4%B8%80%E4%B8%AA%E8%A1%A8%E9%A1%B9%E5%8D%A0%E5%A4%9A%E5%B0%91%E5%AD%97%E8%8A%82%E5%85%B6%E4%B8%AD%E5%93%AA%E5%87%A0%E4%BD%8D%E4%BB%A3%E8%A1%A8%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E4%BB%A3%E7%A0%81%E7%9A%84%E5%85%A5%E5%8F%A3">6.1 中断描述符表中一个表项占多少字节,其中哪几位代表中断处理代码的入口</h4>
<p>中断向量表一个表项占用8字节，其中2-3字节是段选择子，0-1字节和6-7字节拼成位移，两者联合便是中断处理程序的入口地址。</p>
<h4 id="62-%E8%AF%B7%E7%BC%96%E7%A8%8B%E5%AE%8C%E5%96%84-kerntraptrapc-%E4%B8%AD%E5%AF%B9%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%87%BD%E6%95%B0-idtinit%E3%80%82%E5%9C%A8-idtinit%E5%87%BD%E6%95%B0%E4%B8%AD%E4%BE%9D%E6%AC%A1%E5%AF%B9%E6%89%80%E6%9C%89%E4%B8%AD%E6%96%AD%E5%85%A5%E5%8F%A3%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%82%E4%BD%BF%E7%94%A8-mmuh-%E4%B8%AD%E7%9A%84-setgate-%E5%AE%8F%E5%A1%AB%E5%85%85-idt%E6%95%B0%E7%BB%84%E5%86%85%E5%AE%B9%E3%80%82%E6%AF%8F%E4%B8%AA%E4%B8%AD%E6%96%AD%E7%9A%84%E5%85%A5%E5%8F%A3%E7%94%B1-toolsvectorsc-%E7%94%9F%E6%88%90%E4%BD%BF%E7%94%A8-trapc-%E4%B8%AD%E5%A3%B0%E6%98%8E%E7%9A%84-vectors-%E6%95%B0%E7%BB%84%E5%8D%B3%E5%8F%AF%E3%80%82">6.2 请编程完善 kern/trap/trap.c 中对中断向量表进行初始化的函数 idt_init。在 idt_init函数中,依次对所有中断入口进行初始化。使用 mmu.h 中的 SETGATE 宏,填充 idt数组内容。每个中断的入口由 tools/vectors.c 生成,使用 trap.c 中声明的 vectors 数组即可。</h4>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span>
<span class="hljs-title">idt_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
    <span class="hljs-keyword">extern</span> <span class="hljs-keyword">uintptr_t</span> __vectors[];
    
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(idt) / <span class="hljs-keyword">sizeof</span>(struct gatedesc); i ++) 
    {
        SETGATE(idt[i], <span class="hljs-number">0</span>, GD_KTEXT, __vectors[i], DPL_KERNEL);
    }
    <span class="hljs-comment">// load the IDT</span>
    lidt(&amp;idt_pd);
}
</div></code></pre>
<p><code>IDT</code> 的所有内容在 <code>vectors.S</code> 中，
<code>_vectors</code> 其实是在 <code>vectors.S</code> 中定义的，在这里声明了一下，然后使用宏 <code>SETGATE</code> 将所有装入 <code>idt</code>，最后调用 <code>lidt</code> 指令装载 <code>IDT</code>。</p>
<h4 id="63-%E8%AF%B7%E7%BC%96%E7%A8%8B%E5%AE%8C%E5%96%84-trapc-%E4%B8%AD%E7%9A%84%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0-trap%E5%9C%A8%E5%AF%B9%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86%E7%9A%84%E9%83%A8%E5%88%86%E5%A1%AB%E5%86%99-trap-%E5%87%BD%E6%95%B0%E4%B8%AD%E5%A4%84%E7%90%86%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD%E7%9A%84%E9%83%A8%E5%88%86%E4%BD%BF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%AF%8F%E9%81%87%E5%88%B0-100-%E6%AC%A1%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD%E5%90%8E%E8%B0%83%E7%94%A8-printticks%E5%AD%90%E7%A8%8B%E5%BA%8F%E5%90%91%E5%B1%8F%E5%B9%95%E4%B8%8A%E6%89%93%E5%8D%B0%E4%B8%80%E8%A1%8C%E6%96%87%E5%AD%97%E2%80%9D100-ticks%E2%80%9D%E3%80%82">6.3 请编程完善 trap.c 中的中断处理函数 trap,在对时钟中断进行处理的部分填写 trap 函数中处理时钟中断的部分,使操作系统每遇到 100 次时钟中断后,调用 print_ticks子程序,向屏幕上打印一行文字”100 ticks”。</h4>
<p>这个任务比较简单
在 <code>vecters.S</code> 中可以发现每个中断服务程序后面都有 <code>jmp __alltraps</code> 指令， <code>__alltraps</code> 在 <code>trapentry.S</code> 中，可以发现它会调用 <code>trap</code>，所以每当终端发生，就会执行 <code>trap_dispatch</code>，在其中添加如下代码即可</p>
<pre class="hljs"><code><div>    <span class="hljs-keyword">case</span> IRQ_OFFSET + IRQ_TIMER:
        ticks++;
        <span class="hljs-keyword">if</span>(ticks % TICK_NUM == <span class="hljs-number">0</span>)
            print_ticks();
        <span class="hljs-keyword">break</span>;
</div></code></pre>
<h3 id="%E6%89%A9%E5%B1%95%E7%BB%83%E4%B9%A0">扩展练习</h3>
<h4 id="71-%E6%89%A9%E5%B1%95-proj4%E5%A2%9E%E5%8A%A0-syscall-%E5%8A%9F%E8%83%BD%E5%8D%B3%E5%A2%9E%E5%8A%A0%E4%B8%80%E7%94%A8%E6%88%B7%E6%80%81%E5%87%BD%E6%95%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E4%B8%80%E7%89%B9%E5%AE%9A%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%8E%B7%E5%BE%97%E6%97%B6%E9%92%9F%E8%AE%A1%E6%95%B0%E5%80%BC%E5%BD%93%E5%86%85%E6%A0%B8%E5%88%9D%E5%A7%8B%E5%AE%8C%E6%AF%95%E5%90%8E%E5%8F%AF%E4%BB%8E%E5%86%85%E6%A0%B8%E6%80%81%E8%BF%94%E5%9B%9E%E5%88%B0%E7%94%A8%E6%88%B7%E6%80%81%E7%9A%84%E5%87%BD%E6%95%B0%E8%80%8C%E7%94%A8%E6%88%B7%E6%80%81%E7%9A%84%E5%87%BD%E6%95%B0%E5%8F%88%E9%80%9A%E8%BF%87%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%BE%97%E5%88%B0%E5%86%85%E6%A0%B8%E6%80%81%E7%9A%84%E6%9C%8D%E5%8A%A1%E3%80%82">7.1 扩展 proj4,增加 syscall 功能,即增加一用户态函数(可执行一特定系统调用:获得时钟计数值),当内核初始完毕后,可从内核态返回到用户态的函数,而用户态的函数又通过系统调用得到内核态的服务。</h4>
<p>在 <code>idt_init</code> 中添加</p>
<pre class="hljs"><code><div>    SETGATE(idt[T_SWITCH_TOK], <span class="hljs-number">1</span>, KERNEL_CS, __vectors[T_SWITCH_TOK], DPL_USER);
</div></code></pre>
<p>从而添加一个用户态的中断服务程序。</p>
<p>在 <code>lab1_switch_to_user</code> 中调用 <code>T_SWITCH_TOU</code> 中断</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>
<span class="hljs-title">lab1_switch_to_user</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
    <span class="hljs-comment">//LAB1 CHALLENGE 1 : TODO</span>
	<span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span> <span class="hljs-params">(
	    <span class="hljs-string">"sub $0x8, %%esp \n"</span>
	    <span class="hljs-string">"int %0 \n"</span>
	    <span class="hljs-string">"movl %%ebp, %%esp"</span>
	    : 
	    : <span class="hljs-string">"i"</span>(T_SWITCH_TOU)</span>
	)</span>;
}
</div></code></pre>
<p>在 <code>lab1_switch_to_kernel</code> 中调用 <code>T_SWITCH_TOK</code> 中断</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>
<span class="hljs-title">lab1_switch_to_kernel</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
    <span class="hljs-comment">//LAB1 CHALLENGE 1 :  TODO</span>
    <span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span> <span class="hljs-params">(
	    <span class="hljs-string">"int %0 \n"</span>
	    <span class="hljs-string">"movl %%ebp, %%esp \n"</span>
	    : 
	    : <span class="hljs-string">"i"</span>(T_SWITCH_TOK)</span>
	)</span>;
}
</div></code></pre>
<p>最后对 <code>trap_dispatch</code> 中的 <code>T_SWITCH_TOU</code> 和 <code>T_SWITCH_TOK</code> 两个 <code>case</code> 进行修改</p>
<pre class="hljs"><code><div>    <span class="hljs-comment">//LAB1 CHALLENGE 1 : YOUR CODE you should modify below codes.</span>
    <span class="hljs-keyword">case</span> T_SWITCH_TOU:
        <span class="hljs-keyword">if</span> (tf-&gt;tf_cs != USER_CS) {
            switchk2u = *tf;
            switchk2u.tf_cs = USER_CS;
            switchk2u.tf_ds = switchk2u.tf_es = switchk2u.tf_ss = USER_DS;
            switchk2u.tf_esp = (<span class="hljs-keyword">uint32_t</span>)tf + <span class="hljs-keyword">sizeof</span>(struct trapframe) - <span class="hljs-number">8</span>;
		
            <span class="hljs-comment">// set eflags, make sure ucore can use io under user mode.</span>
            <span class="hljs-comment">// if CPL &gt; IOPL, then cpu will generate a general protection.</span>
            switchk2u.tf_eflags |= FL_IOPL_MASK;
		
            <span class="hljs-comment">// set temporary stack</span>
            <span class="hljs-comment">// then iret will jump to the right stack   </span>
            *((<span class="hljs-keyword">uint32_t</span> *)tf - <span class="hljs-number">1</span>) = (<span class="hljs-keyword">uint32_t</span>)&amp;switchk2u;
        }
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> T_SWITCH_TOK:
        <span class="hljs-keyword">if</span> (tf-&gt;tf_cs != KERNEL_CS) {
            tf-&gt;tf_cs = KERNEL_CS;
            tf-&gt;tf_ds = tf-&gt;tf_es = KERNEL_DS;
            tf-&gt;tf_eflags &amp;= ~FL_IOPL_MASK;
            switchu2k = (struct trapframe *)(tf-&gt;tf_esp - (<span class="hljs-keyword">sizeof</span>(struct trapframe) - <span class="hljs-number">8</span>));
            memmove(switchu2k, tf, <span class="hljs-keyword">sizeof</span>(struct trapframe) - <span class="hljs-number">8</span>);
            *((<span class="hljs-keyword">uint32_t</span> *)tf - <span class="hljs-number">1</span>) = (<span class="hljs-keyword">uint32_t</span>)switchu2k;
        }
        <span class="hljs-keyword">break</span>;
</div></code></pre>
<h4 id="72-%E7%94%A8%E9%94%AE%E7%9B%98%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%E5%86%85%E6%A0%B8%E6%A8%A1%E5%BC%8F%E5%88%87%E6%8D%A2%E3%80%82%E5%85%B7%E4%BD%93%E7%9B%AE%E6%A0%87%E6%98%AF%E2%80%9C%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5-3-%E6%97%B6%E5%88%87%E6%8D%A2%E5%88%B0%E7%94%A8%E6%88%B7%E6%A8%A1%E5%BC%8F%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5-0-%E6%97%B6%E5%88%87%E6%8D%A2%E5%88%B0%E5%86%85%E6%A0%B8%E6%A8%A1%E5%BC%8F%E2%80%9D%E3%80%82-%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF%E6%98%AF%E5%80%9F%E9%89%B4%E8%BD%AF%E4%B8%AD%E6%96%ADsyscall-%E5%8A%9F%E8%83%BD%E7%9A%84%E4%BB%A3%E7%A0%81%E5%B9%B6%E4%B8%94%E6%8A%8Atrapc-%E4%B8%AD%E8%BD%AF%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%9A%84%E8%AE%BE%E7%BD%AE%E8%AF%AD%E5%8F%A5%E6%8B%BF%E8%BF%87%E6%9D%A5">7.2 用键盘实现用户模式内核模式切换。具体目标是:“键盘输入 3 时切换到用户模式,键盘输入 0 时切换到内核模式”。 基本思路是借鉴软中断(syscall 功能)的代码,并且把trap.c 中软中断处理的设置语句拿过来</h4>
<p>在实现 <code>7.1</code> 的情况下，直接将用户态和内核态相互切换的放到 <code>case IRQ_OFFSET + IRQ_KBD</code> ，加上对键盘输入的判断即可</p>
<pre class="hljs"><code><div>    <span class="hljs-keyword">case</span> IRQ_OFFSET + IRQ_KBD:
        c = cons_getc();
        <span class="hljs-keyword">if</span>(c == <span class="hljs-number">51</span>)
        {
            cprintf(<span class="hljs-string">"kbd [%03d] %c\n"</span>, c, c);
            <span class="hljs-keyword">if</span> (tf-&gt;tf_cs != USER_CS) {
            switchk2u = *tf;
            switchk2u.tf_cs = USER_CS;
            switchk2u.tf_ds = switchk2u.tf_es = switchk2u.tf_ss = USER_DS;
            switchk2u.tf_esp = (<span class="hljs-keyword">uint32_t</span>)tf + <span class="hljs-keyword">sizeof</span>(struct trapframe) - <span class="hljs-number">8</span>;
		
            <span class="hljs-comment">// set eflags, make sure ucore can use io under user mode.</span>
            <span class="hljs-comment">// if CPL &gt; IOPL, then cpu will generate a general protection.</span>
            switchk2u.tf_eflags |= FL_IOPL_MASK;
		
            <span class="hljs-comment">// set temporary stack</span>
            <span class="hljs-comment">// then iret will jump to the right stack   </span>
            *((<span class="hljs-keyword">uint32_t</span> *)tf - <span class="hljs-number">1</span>) = (<span class="hljs-keyword">uint32_t</span>)&amp;switchk2u;
            }
            print_trapframe(tf);
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-number">48</span>)
        {
            cprintf(<span class="hljs-string">"kbd [%03d] %c\n"</span>, c, c);
            <span class="hljs-keyword">if</span> (tf-&gt;tf_cs != KERNEL_CS) {
            tf-&gt;tf_cs = KERNEL_CS;
            tf-&gt;tf_ds = tf-&gt;tf_es = KERNEL_DS;
            tf-&gt;tf_eflags &amp;= ~FL_IOPL_MASK;
            switchu2k = (struct trapframe *)(tf-&gt;tf_esp - (<span class="hljs-keyword">sizeof</span>(struct trapframe) - <span class="hljs-number">8</span>));
            memmove(switchu2k, tf, <span class="hljs-keyword">sizeof</span>(struct trapframe) - <span class="hljs-number">8</span>);
            *((<span class="hljs-keyword">uint32_t</span> *)tf - <span class="hljs-number">1</span>) = (<span class="hljs-keyword">uint32_t</span>)switchu2k;
            }
            print_trapframe(tf);
        }
        <span class="hljs-keyword">else</span>
            cprintf(<span class="hljs-string">"kbd [%03d] %c\n"</span>, c, c);
        <span class="hljs-keyword">break</span>;
</div></code></pre>

</body>
</html>
